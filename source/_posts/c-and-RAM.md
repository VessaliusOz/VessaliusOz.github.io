---
title: C语言和内存
date: 2018-03-08 12:49:57
tags: 
	- C语言
	- 内存
---

# C语言和内存

## 概述
最近又重新开始看关于C语言的东西了。感觉自己的python学的还可以，但是学了python之后，觉得`python`对底层的细节封装的太好了，所以对很多东西都是知其然不知其所以然。想着python其实是使用C语言实现的，所以就又重新开始鼓捣C语言的东西了。

其实C语言在大一上的时候就学习了，但是因为当时自己是第一次接触，也没有带电脑，实践的时间又非常少，所以打心底有点畏惧，觉得C语言很难，就失去了学习的动力。不过后来在学习python的时候，渐渐发现自己其实是非常喜欢编程的，而且有了学习python的经验，摸清了学习编程的路子，感觉就是要多写，多思考，所以就对学好C语言也非常的有信心了。

<!--more-->
## C语言和内存

### 类型的意义
C语言其实对内存地址做了一些封装。比如下面这段代码:

```C
int a；
a = 5;
a += 4；            // 结果a等于9
```

这几个语句的作用是:
`int a`: 编译器帮我们申请了一个int类型的内存格子（长度是4字节，地址是确定的，但是只有编译器知道，我们是不知道的，也不需要知道），并且把符号a和这个格子绑定。

`a = 5`：编译器发现我们要给a赋值，就会把这个值5丢到符号a绑定的那个内存格子中。

`a += 4`：编译器发现我们要给a加值，a += 4等效于a = a + 4，编译器会先把a原来的值读出来，然后给这个值加4，再把加之后的和写入a里面去，最后这个格子里面存储的内容就是9。

所以我们可以看出来，在C语言中指定数据类型的本质含义:

* 表示内存的长度
  
  如一个内存地址（0x30000000），本来只代表一个字节的长度，但是实际上我们可以通过给它一个类型（int），让它有了长度（4），这样这个代表内存地址的数字0x30000000，就能表示从这个数字开头的连续n（4）个字节的内存格子了，即0x30000000 + 0x30000001 + 0x30000002 + 0x30000003。
  
* 指定对这块内存内容的解析方法
	
	假如有一个内存地址（0x30000000），我们可以通过给这个内存地址不同的类型来指定这个内存单元格子中二进制数的解析方法。如int的含义就是0x30000000 + 0x30000001 + 0x30000002 + 0x30000003这四个字节连起来共同存储的是一个int型数据；那float的含义就是0x30000000 + 0x30000001 + 0x30000002 + 0x30000003这四个字节连起来共同存储的是一个float型数据。
	

同样，我们可以发现，C语言中的函数也是如此。在C语言中，函数就是一段代码的封装。函数名的实质就是这一段代码的首地址，所以说函数名的本质也是一个内存地址。有了函数名（指针），也就是有了地址，我们才实现了函数的调用。
 
 知道了这个，我们应该会对指针也有了进一步的认识。就像在定义指针的时候，我们也要指定指针的类型。我们知道，指针其实也是一个变量，不过指针这个变量存储的值是一个地址。 当我们得到这个地址的时候，我们并不能知道从这个地址开始，所需要的内存的长度是多少，所应该使用的解析方法是怎么样的。所以只有当我们知道这个指针的类型(也就是这个指针所指向的内存地址存储的数据的类型)时，我们才能确定对应的长度和解析方法。同样，我们定义了一个变量为指针变量，比如`int *`，那么这个变量的类型就是`int *`，所以我们在解析这块地址的时候，就要读取`int *`变量所需要的长度，以及调用相应解析的方法。
 
题外话：

用结构体来实现面向的对象的写法:

```C
structs
{
int age;                  // 普通变量
void (*pFunc)(void);      // 函数指针，指向void func(void)
};
```
	 
使用这样的结构体就可以实现面向对象，这样包含了函数指针的结构体就类似于面向对象中的class，结构体中的变量类似于class中的成员变量，结构体中的函数指针类似于class中的成员方法。

数组名和函数名都是指针， 但是结构体名不是指针。

### 内存分配的方式

#### C语言内存管理--栈
引入的例子:
```C
	// 两个函数
	char * toStr() {
	    char *s;
	    s = "173y267846394";
	    return s;
	};
	
	char * toStrArr() {
	    char s[] = "173y267846394";
	    return s;  //<-- Address of stack memory associated with local variable 's' returned 这里是警告的信息⚠️
	};
	
	// 打印的结果
		printf("%s\n", toStr());
		printf("%s\n", toStrArr());
	    
	173y267846394
							// <-----这里没有打印出来
	Program ended with exit code: 0
```

我们发现这里出现了一个`Address of stack memory`这样的消息，是**栈内存**。然后为什么没有打印出来呢？这里就涉及到了C语言内存分配的问题。

我们知道，栈是一种数据结构，C语言中使用栈来保存局部变量（注意，下文中不强调的情况下，局部变量均指非静态局部变量）。栈是被发明出来管理内存的，是一种维护内存的机制，这就是栈的本质。

C语言中的局部变量是用栈来实现的。

我们在C语言中定义一个局部变量时（int a），编译器会在栈中分配一段空间（4字节）给这个局部变量用。分配时栈顶指针会移动出4个字节空间给局部变量a用的意思就是，将这4字节的栈内存的内存地址和我们定义的局部变量名a关联起来，对应的栈操作为入栈，就是将数据存入变量a中。需要注意的是，这里栈指针的移动和内存分配是自动完成的，不需要程序参与。

然后等我们函数退出的时候，局部变量就会被释放。对应的操作是弹栈（出栈）。出栈时也是栈顶指针移动，将栈空间中与a关联的那4个字节空间释放，这个动作也是自动的，不需要人为干预。**所以我们在写代码的时候，一定不要从被调函数返回一个局部变量的地址给主调函数，因为在函数执行完后局部变量就释放了，这个地址里面的内容有可能被新的内容填充。这时如果你在主调函数里面使用它，就很有可能造成数据错误。**

但是上面的例子来说，不管是`toStr()`还是`toStrArr()`，似乎返回的都是一个局部变量的地址，为什么`toStr()`可以正常返回而`toStrArr()`无法正常返回呢？原因是：

第一种表达式，指针s是局部变量，他的作用域是函数toStr内。它将其指向的地址返回，返回之后s即被销毁，庆幸s指向的地址被返回了回来。s虽然是局部变量，被分配到了栈空间，作用域是函数内部，但是它指向的内容是`173y267846394`,这是一个常量，被分配在程序的常量区，直到整个程序结束才被销毁。

而第二种，s是一数组，分配到栈空间，"173y267846394"作为数组各个元素被放到数组中，一旦函数退出，栈中这块内存就被释放。虽然返回一个地址，可是已经失去它的意义了。所以这里得不到结果。

这里就有引出了另外的一个问题: C语言的内存分配的问题，不同类型的数据都分配在了哪些位置?

#### 内存的分配方式
内存分配方式有三种：

　　1. 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

　　2. 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。(小内存，自动化，栈的大小可以设置)

　　3. 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。(大块内存，手工分配/使用/释放)

以上总结就是:静态存储区对内存的操作比较简单，就是在编译期分配一块确定大小的内存，用来存储数据,全局变量和静态局部变量存在于静态存储区中。局部变量存在于栈（stack）中，动态申请数据存在于堆（heap）中。


关于常见的内存的错误以及处理建议:

* 内存分配未成功，却使用了它
	
	在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。
	
* 忘记了释放内存，造成内存泄露。

	动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。
	
* 释放了内存却继续使用它
	有三种情况：

　　1. 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。

　　2. 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。

　　3. 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。

　　	\* 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
　　	
　　	\* 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

　　	\* 避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。

　　	\* 动态内存的申请与释放必须配对，防止内存泄漏。

　　	\* 用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。



#### 指针与数组的比较
我们通常认为数组名和指针是等价的，因为指针和数组在不少地方可以相互替换着用。但是他们之间还是有区别的：

* 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。
* 指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

我们来看看指针和数组对内容的复制和比较的正确做法：

* 不能对数组名进行直接复制与比较。如下列例子，若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。

* 语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。

```C
// 数组…

char a[] = "hello";

char b[10];

strcpy(b, a); // 不能用 b = a;

if(strcmp(b, a) == 0) // 不能用 if (b == a)

…

// 指针…

int len = strlen(a);

char *p = (char *)malloc(sizeof(char)*(len 1));

strcpy(p,a); // 不要用 p = a;

if(strcmp(p, a) == 0) // 不要用 if (p == a)

…
```



#### 计算内存容量
使用运算符sizeof可以计算出数组的容量（字节数）。示例中，sizeof(a)的值是12（注意别忘了`'\0'`）。指针p指向a，但是 sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。 C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。

```c
char a[] = "hello world";

char *p = a;

cout<< sizeof(a) << endl; // 12字节

cout<< sizeof(p) << endl; // 4字节
```

注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。

```c
void Func(char a[100])

{

　printf("%d\n", sizeof(a)); // 4字节而不是100字节

}

```

#### 指针参数是如何传递内存的
如果函数的参数是一个指针，不要指望用该指针去申请动态内存。示例中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？

```c
void GetMemory(char *p, int num)

{

　p = (char *)malloc(sizeof(char) * num);

}

void Test(void)

{

　char *str = NULL;

　GetMemory(str, 100); // str 仍然为 NULL

　strcpy(str, "hello"); // 运行错误

}
```

毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 \_p，编译器使 \_p = p。如果函数体内的程序修改了\_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把 _p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。所以我们应该:

1.指向指针的指针

	```c
	void GetMemory2(char **p, int num)
	
	{
	// p指向的内容是一个指向 sizeof(char) * num 这么大内存的一个指针
	　*p = (char *)malloc(sizeof(char) * num);
	
	}
	
	void Test2(void)
	
	{
	
	　char *str = NULL;
	
	　GetMemory2(&str, 100); // 注意参数是 &str，而不是str
	
	　strcpy(str, "hello");
	
	　printf("%s", str);
	
	　free(str);
	
	}
	```

2.由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单:

```c
char *GetMemory3(int num)

{

　char *p = (char *)malloc(sizeof(char) * num);

　return p;

}

void Test3(void)

{

　char *str = NULL;

　str = GetMemory3(100);

　strcpy(str, "hello");

　printf("%s", str);

　free(str);

}
```
用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡。这里又再一次强调了不要在被调函数中返回`栈指针`。这里p是栈变量，但是它指向的地址是堆内存里面的。

#### malloc/free的使用方法
1.函数malloc的原型如下：

	```c
	void * malloc(size_t size);
	```
	
用malloc申请一块长度为length的整数类型的内存，程序如下：
		
```c
int *p = (int *) malloc(sizeof(int) * length);
```
我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。
	
* malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void * 转换成所需要的指针类型。
* malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。


2.函数free的原型如下：

```c
void free( void * memblock );
```
为什么free 函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是 NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。


### 一些心得体会
这次是重新开始学习C语言，对之前的一些问题也有了非常好的理解了，至少现在来说，我并不害怕指针了，可能经验还是不够，但是至少我敢用，敢写了，就算错了也可以静下心来一步一步的调试找到原因。

我的经验教训是：

1. 越是怕指针，就越要使用指针。不会正确使用指针，肯定算不上是合格的程序员。
2. 问题并不可怕，与其急急燥燥焦头烂额，不如静下心来查资料，看官方文档，问题总是可以解决的。而且我们现在遇到的问题基本上可以说是前人都遇到过的问题，所以一定会有解决方案的。

以前心情非常的急躁，每次遇到问题都会焦头烂额，在焦虑中浪费时间。但是感觉自己在差不多两年的编程时间里，最大的收获是对心境的培养。只要冷静分析静下心来调试和搜寻解决方案，没有什么是不可以解决的。






